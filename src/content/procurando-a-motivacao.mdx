---
title: Procurando a motivaÃ§Ã£o
published: true
flavor_text: Uma pequena coleÃ§Ã£o de histÃ³rias pessoais sobre como entender o objetivo da tarefa ajuda a executarmos ela melhor
published_at: 2023-04-20 16:43 -0300
---

Esse post nÃ£o Ã© sobre cÃ³digo. Mesmo se nÃ£o souber programar, vocÃª nÃ£o deve ter dificuldades em acompanhar ğŸ˜„

---

Eu jÃ¡ ouvi bastante feedback no meu trabalho. O mais constante sendo melhorias de comunicaÃ§Ã£o, que atÃ© hoje tenho certo problema.

Um problema que ocorria frequentemente era que as minhas explicaÃ§Ãµes que eram muito tÃ©cnicas. Na minha conversa com o time de produto isso complicava tudo. Por exemplo, eu explicava todo o contexto por volta de uma nova implementaÃ§Ã£o de feature. Levantava as possibilidades que conseguia pensar, trazendo as facilidades e dificuldades que trariam na implementaÃ§Ã£o inicial e na manutenÃ§Ã£o do cÃ³digo. Eu estava pensando comigo mesmo e sendo transparente com todo mundo.

Isso era relevante se fosse discutir com pessoas mais seniores, mas raramente era o caso. O que aprendi com o tempo era entender o escopo do que as pessoas _precisavam_ saber, e trazer isso a elas. Entender o porquÃª daquela comunicaÃ§Ã£o existir, e relevar o que exatamente eu precisava comunicar de acordo com esse motivo.

Aplicando isso, as mensagens de Slack que eram 5 parÃ¡grafos gigantes explicando os pormenores da entrega viravam 5 frases breves focando no que a pessoa precisava saber. Pra escrever as 5 frases eu ainda demoro, mas a comunicaÃ§Ã£o fica bem mais fluÃ­da assim.

---

Eu lembro quando eu criava testes de componentes React usando Enzyme. Foi Ã³timo aprender o mundo frontend com ele, porque eram simples, e qualquer um poderia criar testes sem esforÃ§o.

```js
it("renders", () => {
	const wrapper = shallow(<Component />)
	expect(wrapper).toMatchSnapshot()
})
```

Eu gosto de pensar nesses testes como "snacks", eles sÃ£o rÃ¡pidos de serem escritos e entendidos, e raramente quebram. Se quebrar, era um processo simples corrigir eles, geralmente eu apertava U no teclado e o snapshot atualizava sozinho, eu nem precisava verificar.

Mas uma coisa que ficava escondida para mim era que os testes, sendo fÃ¡ceis de serem mantidos, eram tambÃ©m _muito_ inÃºteis. Muitos bugs passavam nesse mÃ©todo, e no final o valor dos testes era bem limitado.

React Testing Library chega na minha vida. Ela vem com um princÃ­pio:

> The more your tests resemble the way your software is used, the more confidence they can give you.

Essa pequena frase afeta bastante. Para seguir esse princÃ­pio, a React Testing Library tem **menos** possibilidades do que a Enzyme, mas o que pra mim parecia um detrator da lib acabava sendo uma vantagem. Isso diminui o foco na estrutura do cÃ³digo, e aumenta o foco no usuÃ¡rio como valor principal dos testes.

Eu sÃ³ fazia testes porque era considerado boa prÃ¡tica, mas nenhum momento eu tinha pensado em um Objetivo dos testes, que colocava valor nos testes em si. Eu nem precisava da React Testing Library pra aplicar esse princÃ­pio. Ao me restringir dentro do Enzyme, eu criava testes com mais valor.

---

DRY (_Don't Repeat Yourself_ ou _NÃ£o Se Repita_) Ã© um acrÃ´nimo bem popular de boa prÃ¡tica no mundo da programaÃ§Ã£o. A ideia dele Ã© reduzir retrabalho com a regra de nÃ£o duplicar cÃ³digo.

Essa regra Ã© aplicada nÃ£o sÃ³ no frontend, mas em todos os nÃ­veis de programaÃ§Ã£o que jÃ¡ vi. E de longe Ã© a mais popular e mais implementada por times. Uma crÃ­tica recente a essa "boa prÃ¡tica" Ã© que ela introduz cÃ³digos complexos demais com o tempo.

O processo acaba sendo o seguinte: uma pessoa evita repetir o cÃ³digo introduzindo uma abstraÃ§Ã£o. Outra pessoa, considerando que precisa dessa abstraÃ§Ã£o, usa ela e altera pro seu caso. E mais uma pessoa, e outra, assim vai indo. AtÃ© que a abstraÃ§Ã£o nÃ£o faz mais sentido, mas Ã© utilizada por todos.

Outras regras foram introduzidas para mitigar esse problema. WET (_Write Everything Twice_ ou _Escreva Tudo Duas Vezes_) Ã© uma regra que diz: "Todo cÃ³digo deve ser escrito no mÃ¡ximo duas vezes". Ã‰ uma regra que mitiga esses problemas, mas ao meu ver tem outra regra, ou melhor, ideia, que diminui a complexidade de cÃ³digo, o [AHA](https://dev.to/cher/avoiding-hasty-abstractions-aha-programming-3d3b): "Avoid Hasty Abstractions" (ou Evite AbstraÃ§Ãµes Apressadas).

A ideia do AHA programming Ã© introduzir abstraÃ§Ãµes no cÃ³digo quando elas forem necessÃ¡rias, e diminuir o uso de abstraÃ§Ãµes simplesmente por abstrair.

A vantagem (e desvantagem) do AHA Ã© que ele nÃ£o dÃ¡ uma regra fÃ¡cil de ser seguida. Ele abre mÃ£o de uma regra definida para que a pessoa desenvolvendo consiga determinar vÃ¡rios fatores que definam se tal abstraÃ§Ã£o Ã© necessÃ¡ria. Isso faz com que alguns casos apareÃ§am meio estranhos, por exemplo:

```js
const DEBUG_QUERY_PARAM = "shouldDebug"

function Component() {
	const { search } = useLocation()
	// ...

	const doSomething = () => {
		const shouldDebug = new URLQueryParams(
			location.search
		).has(DEBUG_QUERY_PARAM)
		if (shouldDebug) {
			console.log("debugging happening")
		}
		// ...
	}
}
```

Esse cÃ³digo tem duas abstraÃ§Ãµes relevantes: `DEBUG_QUERY_PARAM` e `shouldDebug`. Ambas existem mas sÃ³ sÃ£o utilizadas uma vez.

Se for se basear sÃ³ nas regras de DRY ou WET, ambas as abstraÃ§Ãµes nÃ£o fazem sentido, elas estÃ£o sendo usadas sÃ³ uma vez no cÃ³digo. Mas Ã© importante capturar o propÃ³sito real por traz delas antes de removÃª-las.

`DEBUG_QUERY_PARAM` tem uma valor de documentar o comportamento. Ele informa pra quem estÃ¡ lendo que existe uma funÃ§Ã£o de debug do cÃ³digo, e ele Ã© controlado pela query param `shouldDebug`. A intenÃ§Ã£o do cÃ³digo nÃ£o Ã© reuso, mas sim documentaÃ§Ã£o de uma feature.

`shouldDebug` tem o propÃ³sito de abstrair um cÃ³digo complexo em um cÃ³digo fÃ¡cil de ser entendido por um humano, pode inclusive ensinar atravÃ©s dessa interface amigÃ¡vel. AlÃ©m disso, ele representa melhor a intenÃ§Ã£o da pessoa que o criou, fazendo o trabalho de manutenÃ§Ã£o mais fÃ¡cil caso haja algum bug.

> âš ï¸ Eu nÃ£o estou necessariamente dizendo que o cÃ³digo escrito Ã© um bom cÃ³digo. Leve em conta o contexto dele antes de aplicar o mesmo racional.

## Por quÃª?

Essas historietas estÃ£o conectadas por uma ideia, sintetizada por uma/duas palavra(s): "Por quÃª?" Pra trazer valor em uma tarefa, eu preciso entender o motivo dela.

JÃ¡ vi uma tÃ©cnica chamada "Os 5 porquÃªs", criada com o objetivo de chegar Ã  raiz do problema. Nela, vocÃª entra numa recursÃ£o: pergunta o motivo de um problema ocorrer, e depois disso procura explicar porque esse motivo existe, e continuamente.

Essa tÃ©cnica pode ser aplicada onde vocÃª ainda nÃ£o enxerga problemas. Tente entender a motivaÃ§Ã£o por trÃ¡s. Essa motivaÃ§Ã£o nÃ£o precisa ser a melhor do mundo, mas tem que ser sincera. Se vocÃª quer usar TypeScript invÃ©s de JS, vocÃª nÃ£o precisa falar que tem mais qualidade ou os mesmos argumentos de sempre. Os argumentos podem ser baseados no seu contexto: talvez vocÃª queira experimentar TS no seu projeto, ou vocÃª queira melhorar seu portifÃ³lio profissional.

## _Post Scriptum_

Sendo um pouco meta aqui e aplicando o post no prÃ³prio. Eu jÃ¡ tentei escrever muito, mas nunca terminei de escrever. Falei sobre esse assunto no post porque Ã© um assunto que tenho muito o que falar, o que facilita a escrever. E no final, quero escrever posts como esse como parte da minha vida profissional.
